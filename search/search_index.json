{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Main page","text":"<p>Are held every Saturday, 19:00 ~ 20:30 by @argumentofperiapsis</p> <p>Attendance is very appreciated </p>"},{"location":"#approximate-syllabus","title":"Approximate syllabus","text":"Date Topics 11/11 DP &amp; Graph traversal algorithms"},{"location":"graph-dp/","title":"DP &amp; Graph traversal","text":""},{"location":"graph-dp/#dynamic-programming","title":"Dynamic programming","text":"<p>Dynamic programming is when we have a problem that we don't know how to solve, and we split it into smaller problems that we also don't know how to solve.</p> <p>Dynamic programming is an approach that is somewhat similar to mathematical induction that usually boils down to the following steps:</p> <ul> <li>We find how the solution for a given set of parameters (e.g. \\(n\\)) is related to the solution for a smaller set of parameters;</li> <li>We create an array (or any other DS) to store answers for our subtasks;</li> <li>We initialize it with solutions for known small (i.e. base) cases;</li> <li>We traverse that structure from known to unknown parameter sets, updating optimal answers;</li> <li>We return the answer (it is likely already computed, or we descend back through this structure and rebuild the path to it)</li> </ul> <p>It is helpful to give answers to following questions when solving a DP problem:</p> <ol> <li>What do we store?</li> <li>What are the base cases?</li> <li>How to traverse the array? (or any other structure)</li> <li>How to compute new values?</li> <li>Where is the answer stored?</li> </ol>"},{"location":"graph-dp/#simple-dp","title":"Simple DP","text":"<p>A grasshopper can jump either a single cell, or two cells forward. How many ways are there to get from the first cell to the \\(n\\)-th?</p> <p>Let's follow the steps:</p> <ol> <li>We store the solution for the \\(k\\)-th cell;</li> <li>There is a single way to reach the first cell (i.e. \\(dp[0] \\coloneqq 1\\))</li> <li>We iterate over the array indices, starting with \\(0\\) up to \\(n\\);</li> <li>\\(dp[k] = dp[k - 1] + dp[k - 2]\\);</li> <li>The answer is in the \\(n\\)-th cell, that is \\(dp[n]\\).</li> </ol> <p>Here is a simple implementation: Naive implementation<pre><code>uint64_t Solution(size_t n) {\n  std::vector&lt;uint64_t&gt; ways_count(n); // zero-based indexing :)\n  ways_count[0] = 1;\n\n  for (size_t index = 1; index &lt; n; ++index) {\n    ways_count[index] = ways_count[index - 1] +\n      (index &gt; 1 ? ways_count[index - 2] : 0);\n  }\n\n  return ways_count[n - 1];\n}\n</code></pre></p> <p>Note that we have to use only the last two values, so we can optimize our solution a little bit:</p> O(1) extra space implementation<pre><code>uint64_t Solution(size_t n) {\n  uint64_t ways_count = 1;\n  uint64_t previous_ways_count = 0;\n\n  for (size_t index = 1; index &lt; n; ++index) {\n    std::tie(ways_count, previous_ways_count) =\n      std::make_tuple(ways_count + previous_ways_count, ways_count);\n  }\n\n  return ways_count;\n}\n</code></pre> <p>The same approach can be used in multidimensional cases or in case of subtrees, we just change the dimensions of the \\(dp\\) array.</p>"},{"location":"graph-dp/#matrix-dp","title":"Matrix DP","text":"<p>Actually, we can do faster than \\(O(n)\\). We have a linear recurrence relation with constant coefficients: \\(dp_n = dp_{n - 1} + dp_{n - 2}\\).</p> <p>Linear recurrence relations and matrices</p> <p>If we have a following relation: \\(a_n = c_{n - 1} a_{n - 1} + c_{n - 2} a_{n - 2} + \\ldots + c_1 a_1\\), then we can add the following equations: \\(a_{n - 1} = a_{n - 1}, \\ldots, a_2 = a_2\\), and get a following matrix equation: $$ \\begin{pmatrix} a_{n} \\\\ a_{n - 1} \\\\ a_{n - 2} \\\\ \\vdots \\\\ a_2 \\end{pmatrix} = \\underset{A}{\\underbrace{\\begin{pmatrix}   c_{n - 1} &amp; c_{n - 2} &amp; \\ldots &amp; c_1 \\\\   1 &amp; 0 &amp; \\ldots &amp; 0 \\\\   0 &amp; 1 &amp; \\ldots &amp; 0 \\\\   \\vdots &amp; \\ddots &amp; \\vdots &amp; \\vdots \\\\   0 &amp; \\ldots &amp; 1 &amp; 0 \\end{pmatrix}}} \\begin{pmatrix} a_{n - 1} \\\\ a_{n - 2} \\\\ a_{n - 3} \\\\ \\vdots \\\\ a_1 \\end{pmatrix}. $$</p> <p>Observe that each multiplication by \\(A\\) shifts the vector by one position. Now it's trivial to see that \\(a_{n + k}\\) will be the first element of our vector, multiplied by \\(A^{k - 1}\\) .</p> <p>So the answer can be computed as such: \\(\\begin{pmatrix} a_{n + 1} \\\\\\\\ a_{n} \\end{pmatrix} = \\begin{pmatrix} 1 &amp; 1 \\\\\\\\ 1 &amp; 0 \\end{pmatrix}^n \\cdot \\begin{pmatrix} 1 \\\\\\\\ 0 \\end{pmatrix}\\).</p> <p>We can calculate \\(A^n\\) in \\(O(\\log n)\\) time due to following relation: $ A^n = \\begin{cases} A^{n/2} \\cdot A^{n/2} &amp; 2 \\mid n \\\\ A \\cdot A^{n - 1} &amp; 2 \\nmid n \\end{cases}$</p> Pseudocode<pre><code>// class Matrix { ... };\n// class Vector { ... };\n\nuint64_t Solution(size_t n) {\n  Matrix multiplier = {{1, 1}, {1, 0}};\n  Vector base_vector = {1, 0};\n\n  while (n &gt; 0) {\n    if (n % 2 == 0) {\n      multiplier *= multiplier;\n      n /= 2;\n    } else {\n      multiplier *= Matrix{{1, 1}, {1, 0}};\n      --n;\n    }\n  }\n\n  return (multiplier * base_vector)[1];\n}\n</code></pre>"},{"location":"graph-dp/#bitmask-dp","title":"Bitmask DP","text":"<p>What if we need to depend on the answer on various subsets? The answer is to use a bitmask as one of the parameters, which will represent used elements.</p> <ul> <li>To check if a \\(k\\)-th element is used: <code>(mask &amp; (1ULL &lt;&lt; k)) != 0</code>;</li> <li>To add a \\(k\\)-th element into a subset: <code>mask |= (1ULL &lt;&lt; k)</code>;</li> <li>To remove a \\(k\\)-th element into a subset: <code>mask = mask &amp;= ~(1ULL &lt;&lt; k)</code>;</li> <li>To \"flip\" a \\(k\\)-th element: <code>mask ^= (1ULL &lt;&lt; k)</code>;</li> </ul>"},{"location":"graph-dp/#different-other-optimizations","title":"Different other optimizations","text":"<ul> <li>Knuth's optimization &amp; CHT</li> <li>Profile DP</li> <li>Sum-over-subsets DP</li> </ul>"},{"location":"graph-dp/#graph-traversal-algorithms","title":"Graph traversal algorithms","text":"<p>TODO, but the structure is as such:</p> <ol> <li>White-path lemma</li> <li>DFS</li> <li>BFS and why is it needed (same-distance nodes)</li> <li>Cycle search</li> <li>Topological sort</li> <li>0-k BFS</li> </ol>"}]}